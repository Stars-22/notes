# 25.10.16 算法刷题笔记

## 力扣：20. 有效的括号
**链接**：https://leetcode.cn/problems/valid-parentheses/  
**相关标签**：`栈` `字符串`
**难度**：`简单`
### 方法1：`栈`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    bool isValid(string s) {
        int n = s.size(), a[10010], k = 0;
        for(int i=0; i<n; i++){
            a[k++] = s[i];
            if(k > 1){
                if(a[k-2] == '(' && a[k-1] == ')') k = k-2;
                else if(a[k-2] == '{' && a[k-1] == '}') k = k-2;
                else if(a[k-2] == '[' && a[k-1] == ']') k = k-2;
            }
        }
        if(k == 0) return true;
        return false;
    }
};
```

## 力扣：155. 最小栈
**链接**：https://leetcode.cn/problems/min-stack/  
**相关标签**：`栈` `设计`
**难度**：`中等`
### 方法1：`栈`
- **时间复杂度**：
  - push: $O(1)$
  - pop: $O(n)$
  - top: $O(1)$
  - getMin: $O(1)$
- **空间复杂度**：$O(n)$
```cpp
class MinStack {
public:
    int* stack = new int[30000];
    int* min = nullptr;
    int num = 0;
    MinStack() {}
    void push(int val) {
        if(min == nullptr || *min > val) min = stack + num;
        stack[num++] = val;
    }
    void pop() {
        if(--num == 0) min = nullptr;
        else if(min == stack + num){
            min = stack;
            for(int i=1; i<num; i++)
                if(*min > stack[i]) min = stack + i;
        }
    }
    int top() { return stack[num-1]; }
    int getMin() { return *min; }
    ~MinStack() { delete[] stack; }
};
```
### 方法2：`辅助栈`
- **时间复杂度**：
  - push: $O(1)$
  - pop: $O(1)$
  - top: $O(1)$
  - getMin: $O(1)$
- **空间复杂度**：$O(n)$
```cpp
class MinStack {
public:
    int stack[30000];
    int minStack[30000];
    int num = 0;
    MinStack() {}
    void push(int val) {
        if(num == 0 || minStack[num-1] > val) minStack[num] = val;
        else minStack[num] = minStack[num-1];
        stack[num++] = val;
    }
    void pop() { num--; }
    int top() { return stack[num-1]; }
    int getMin() { return minStack[num-1]; }
};
```