# 25.10.23 算法刷题笔记

## 力扣：121. 买卖股票的最佳时机
**链接**：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/  
**相关标签**：`数组` `动态规划`  
**难度**：`简单`
### 方法1：`贪心`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_=100000, ans=0;
        for(auto& price : prices){
            ans = max(ans, price - min_);
            min_ = min(min_, price);
        }
        return ans;
    }
};
```

## 力扣：70. 爬楼梯
**链接**：https://leetcode.cn/problems/climbing-stairs/  
**相关标签**：`记忆化搜索` `数学` `动态规划`  
**难度**：`简单`
### 方法1：`动态规划`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int climbStairs(int n) {
        int a[46] = {1, 1};
        for(int i=2; i<=n; i++) a[i] = a[i-1] + a[i-2];
        return a[n];
    }
};
```

## 力扣：200. 岛屿数量
**链接**：https://leetcode.cn/problems/number-of-islands/  
**相关标签**：`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵`  
**难度**：`中等`
### 方法1：`广度优先搜索`
- **时间复杂度**：$O(mn)$
- **空间复杂度**：$O(min(m,n))$
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size(), ans = 0;
        struct Pos{ int x, y; };
        vector<Pos> a;
        for(int i=0; i<n; i++)
            for(int j=0; j<m; j++)
                if(grid[i][j] == '1'){
                    ans++;
                    grid[i][j] = '0';
                    a.push_back(Pos(i, j));
                    while(a.size() != 0){
                        Pos cur = a.back();
                        a.pop_back();
                        if(cur.x+1 < n && grid[cur.x+1][cur.y] == '1'){
                            grid[cur.x+1][cur.y] = '0';
                            a.push_back(Pos(cur.x+1, cur.y));
                        }
                        if(cur.x-1 >= 0 && grid[cur.x-1][cur.y] == '1'){
                            grid[cur.x-1][cur.y] = '0';
                            a.push_back(Pos(cur.x-1, cur.y));
                        }
                        if(cur.y+1 < m && grid[cur.x][cur.y+1] == '1'){
                            grid[cur.x][cur.y+1] = '0';
                            a.push_back(Pos(cur.x, cur.y+1));
                        }
                        if(cur.y-1 >= 0 && grid[cur.x][cur.y-1] == '1'){
                            grid[cur.x][cur.y-1] = '0';
                            a.push_back(Pos(cur.x, cur.y-1));
                        }
                    }
                }
        return ans;
    }
};
```