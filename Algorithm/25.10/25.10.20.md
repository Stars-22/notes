# 25.10.20 算法刷题笔记

## 力扣：11. 盛最多水的容器
**链接**：https://leetcode.cn/problems/container-with-most-water/  
**相关标签**：`贪心` `数组` `双指针`  
**难度**：`中等`
### 方法1：`双指针`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size()-1, ans = 0;
        while(l != r){
            ans = max(ans, (r-l)*min(height[l], height[r]));
            height[l] < height[r] ? l++ : r--;
        }
        return ans;
    }
};
```

## 力扣：53. 最大子数组和
**链接**：https://leetcode.cn/problems/maximum-subarray/  
**相关标签**：`数组` `分治` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int temp = nums[0], n = nums.size(), ans = temp;
        for(int i=1; i<n; i++){
            if(temp > 0) temp += nums[i];
            else temp = nums[i];
            ans = max(ans, temp);
        }
        return ans;
    }
};
```
### 方法2：`分治`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(\log n)$
```cpp
class Solution {
public:
    struct Node { int l, r, m, s; };
    Node get(vector<int>& nums, int l_, int r_){
        if(l_ == r_) return (Node) {nums[l_], nums[l_], nums[l_], nums[l_]};
        Node l = get(nums, l_, (l_+r_)>>1);
        Node r = get(nums, ((l_+r_)>>1)+1, r_);
        return (Node) { max(l.l, l.s+r.l), max(r.r, r.s+l.r), max(max(l.m, r.m), l.r+r.l), l.s+r.s};
    }
    int maxSubArray(vector<int>& nums) { return get(nums, 0, nums.size()-1).m; }
};
```