# 25.10.31 算法刷题笔记

## 力扣：279. 完全平方数
**链接**：https://leetcode.cn/problems/perfect-squares/  
**相关标签**：`广度优先搜索` `数学` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(n \sqrt n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int numSquares(int n) {
        int dp[10001] = {0};
        memset(dp+1, 1, 10000*sizeof(int));
        for (int i=1; i*i<=n; i++) {
            int num = i * i;
            for (int i=num; i<=n; i++) {
                dp[i] = min(dp[i], dp[i-num]+1);
            }
        }
        return dp[n];
    }
};
```
### 方法2：`动态规划（静态预计算）`
- **时间复杂度**：$O(n \sqrt n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int numSquares(int n) {
        static int dp[10001] = {0, 0};
        if (dp[1] != 0) return dp[n];
        memset(dp+1, 1, 10000*sizeof(int));
        for (int i=1; i*i<=10000; i++) {
            int num = i * i;
            for (int i=num; i<=10000; i++) dp[i] = min(dp[i], dp[i-num]+1);
        }
        return dp[n];
    }
};
```
### 方法3：`数学（四平方和定理）`
- **时间复杂度**：$O(\sqrt n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    bool isP(int n){ return n == pow((int)sqrt(n), 2); }
    bool isPow4(int n){
        while(n % 4 == 0) n /= 4;
        return n % 8 == 7;
    }
    int numSquares(int n) {
        if(isPow4(n)) return 4;
        if(isP(n)) return 1;
        for(int i=1; i*i<n; i++) if(isP(n-i*i)) return 2;
        return 3;
    }
};
```

## 力扣：78. 子集
**链接**：https://leetcode.cn/problems/subsets/  
**相关标签**：`位运算` `数组` `回溯`  
**难度**：`中等`
### 方法1：`迭代法`
- **时间复杂度**：$O(n 2^n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans = {{}};
        for(const auto& a : nums){
            int n = ans.size();
            for(int i=0; i<n; i++){
                vector<int> temp = ans[i];
                temp.push_back(a);
                ans.push_back(temp);
            }
        }
        return ans;
    }
};
```
### 方法2：`位运算（位掩码）`
- **时间复杂度**：$O(n 2^n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans(1<<nums.size());
        for(int i=0; i<(1<<nums.size()); i++)
            for(int j=0; j<nums.size(); j++)
                if((i >> j) & 1) ans[i].push_back(nums[j]);
        return ans;
    }
};
```