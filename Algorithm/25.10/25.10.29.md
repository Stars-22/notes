# 25.10.29 算法刷题笔记

## 力扣：994. 腐烂的橘子
**链接**：https://leetcode.cn/problems/rotting-oranges/  
**相关标签**：`广度优先搜索` `数组` `矩阵` `第 124 场周赛`  
**难度**：`中等`
### 方法1：`多源广度优先搜索`
- **时间复杂度**：$O(mn)$
- **空间复杂度**：$O(mn)$
```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        struct Pos{ int x, y; };
        int orangeNew = 0, ans = 0;
        int n = grid.size(), m = grid[0].size();
        vector<Pos> a;
        for(int i=0; i<n; i++)
            for(int j=0; j<m; j++)
                if(grid[i][j] == 1) orangeNew++;
                else if(grid[i][j] == 2) a.push_back({j, i});
        while(orangeNew > 0 && a.size() > 0){
            vector<Pos> temp;
            while(a.size() > 0){
                int x = a.back().x, y = a.back().y;
                a.pop_back();
                if(y-1 >= 0 && grid[y-1][x] == 1){
                    grid[y-1][x] = 2;
                    orangeNew--;
                    temp.push_back({x, y-1});
                }
                if(x-1 >= 0 && grid[y][x-1] == 1){
                    grid[y][x-1] = 2;
                    orangeNew--;
                    temp.push_back({x-1, y});
                }
                if(y+1 < n && grid[y+1][x] == 1){
                    grid[y+1][x] = 2;
                    orangeNew--;
                    temp.push_back({x, y+1});
                }
                if(x+1 < m && grid[y][x+1] == 1){
                    grid[y][x+1] = 2;
                    orangeNew--;
                    temp.push_back({x+1, y});
                }
            }
            a = move(temp);
            ans++;
        }
        return orangeNew>0 ? -1 : ans;
    }
};
```

## 力扣：234. 回文链表
**链接**：https://leetcode.cn/problems/palindrome-linked-list/  
**相关标签**：`栈` `递归` `链表` `双指针`  
**难度**：`简单`
### 方法1：`快慢指针`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while(fast->next != nullptr){
            fast = fast->next;
            if(fast->next == nullptr) break;
            fast = fast->next;
            slow = slow->next;
        }
        ListNode *cur = slow->next, *last = nullptr;
        while(cur != nullptr){
            ListNode* next = cur->next;
            cur->next = last;
            last = cur;
            cur = next;
        }
        while(head != nullptr && last != nullptr){
            if(head->val != last->val) return false;
            head = head->next;
            last = last->next;
        }
        return true;
    }
};
```