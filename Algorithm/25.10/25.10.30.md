# 25.10.30 算法刷题笔记

## 力扣：102. 二叉树的层序遍历
**链接**：https://leetcode.cn/problems/binary-tree-level-order-traversal/  
**相关标签**：`树` `广度优先搜索` `二叉树`  
**难度**：`中等`
### 方法1：`广度优先搜索`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(!root) return ans;
        queue<TreeNode*> a;
        a.push(root);
        while(!a.empty()){
            int n = a.size();
            vector<int> ans_;
            for(int i=0; i<n; i++) {
                TreeNode* node = a.front();
                a.pop();
                ans_.push_back(node->val);
                if(node->left) a.push(node->left);
                if(node->right) a.push(node->right);
            }
            ans.push_back(move(ans_));
        }
        return ans;
    }
};
```

## 力扣：141. 环形链表
**链接**：https://leetcode.cn/problems/linked-list-cycle/  
**相关标签**：`哈希表` `链表` `双指针`  
**难度**：`简单`
### 方法1：`快慢指针`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head) return false;
        ListNode *l = head, *r = head->next;
        while(l && r){
            if(l == r) return true;
            l = l->next;
            r = r->next;
            if(r) r = r->next;
        }
        return false;
    }
};
```