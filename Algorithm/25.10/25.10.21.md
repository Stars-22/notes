# 25.10.21 算法刷题笔记

## 力扣：46. 全排列
**链接**：https://leetcode.cn/problems/permutations/  
**相关标签**：`数组` `回溯`  
**难度**：`中等`
### 方法1：`回溯(深度优先搜索)`
- **时间复杂度**：$O(nn!)$
- **空间复杂度**：$O(nn!)$
```cpp
class Solution {
public:
    vector<vector<int>> ans;
    void dfs(vector<int>& nums, vector<bool>& used, vector<int>& a){
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(!used[i]){
                a.push_back(nums[i]);
                if(a.size() == n){
                    ans.push_back(a);
                    a.pop_back();
                    return;
                }
                used[i] = true;
                dfs(nums, used, a);
                used[i] = false;
                a.pop_back();
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        vector<int> a;
        dfs(nums, used, a);
        return ans;
    }
};
```

## 力扣：94. 二叉树的中序遍历
**链接**：https://leetcode.cn/problems/binary-tree-inorder-traversal/  
**相关标签**：`栈` `树` `深度优先搜索` `二叉树`  
**难度**：`简单`
### 方法1：`递归(深度优先搜索)`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    void dfs(TreeNode* root, vector<int>& ans){
        if(root == nullptr) return;
        dfs(root->left, ans);
        ans.push_back(root->val);
        dfs(root->right, ans);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        dfs(root, ans);
        return ans;
    }
};
```
### 方法2：`迭代`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<TreeNode*> stack;
        vector<int> ans;
        TreeNode* cur = root;
        while(cur || !stack.empty()){
            while(cur){
                stack.push_back(cur);
                cur = cur->left;
            }
            cur = stack.back();
            stack.pop_back();
            ans.push_back(cur->val);
            cur = cur->right;
        }
        return ans;
    }
};
```
### 方法2：`Morris遍历算法`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        while(root){
            if(!root->left){
                ans.push_back(root->val);
                root = root->right;
            }
            else{
                TreeNode* temp = root->left;
                while(temp->right && temp->right != root) temp = temp->right;
                if(temp->right){
                    temp->right = nullptr;
                    ans.push_back(root->val);
                    root = root->right;
                }
                else{
                    temp->right = root;
                    root = root->left;
                }
            }
        }
        return ans;
    }
};
```

## 力扣：145. 二叉树的后序遍历
**链接**：https://leetcode.cn/problems/binary-tree-postorder-traversal/  
**相关标签**：`栈` `树` `深度优先搜索` `二叉树`  
**难度**：`简单`
### 方法1：`逆序迭代`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<TreeNode*> stack;
        vector<int> ans, ans_;
        TreeNode* cur = root;
        while(cur){
            if(cur->left) stack.push_back(cur->left);
            if(cur->right) stack.push_back(cur->right);
            ans_.push_back(cur->val);
            if (stack.size() == 0) break;
            cur = stack.back(); 
            stack.pop_back();
        }
        for(int i=ans_.size()-1; i>=0; i--) ans.push_back(ans_[i]);
        return ans;
    }
};
```