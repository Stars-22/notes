# 25.10.16 算法刷题笔记

## 力扣：128. 最长连续序列
**链接**：https://leetcode.cn/problems/longest-consecutive-sequence/  
**相关标签**：`并查集` `数组` `哈希表`  
**难度**：`中等`
### 方法1：`哈希表`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> a;
        int ans = 0;
        for(auto& current : nums) a.insert(current);
        auto it = a.begin();
        while (it != a.end()) {
            int num = 1;
            int temp = *it + 1;
            while(a.find(temp) != a.end()){
                a.erase(temp);
                num++;
                temp++;
            }
            temp = *it - 1;
            while(a.find(temp) != a.end()){
                a.erase(temp);
                num++;
                temp--;
            }
            it = a.erase(it);
            ans = max(ans, num);
        }
        return ans;
    }
};
```

## 力扣：55. 跳跃游戏
**链接**：https://leetcode.cn/problems/jump-game/  
**相关标签**：`贪心` `数组` `动态规划`  
**难度**：`中等`
### 方法2：`贪心`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int enable = 0;
        for(int i=0; i<n && i<=enable; i++) enable = max(enable, i + nums[i]);
        if(enable >= n-1) return true;
        else return false;
    }
};
```

## 力扣：136. 只出现一次的数字
**链接**：https://leetcode.cn/problems/single-number/  
**相关标签**：`位运算` `数组`  
**难度**：`简单`
### 方法1：`计数法`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a[60010] = {0};
        for(auto& num : nums) a[num+30000]++;
        for(int i=0; i<60010; i++){
            if(a[i] == 1) return i-30000;
        }
        return 0;
    }
};
```
### 方法2：`位运算`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(auto& num : nums) ans ^= num;
        return ans;
    }
};
```

## 力扣：215. 数组中的第K个最大元素
**链接**：https://leetcode.cn/problems/kth-largest-element-in-an-array/  
**相关标签**：`数组` `分治` `快速选择` `排序` `堆（优先队列）`  
**难度**：`中等`
### 方法1：`堆（优先队列）`
- **时间复杂度**：$O(n \log n)$
- **空间复杂度**：$O(\log n)$
```cpp
class Solution {
public:
    void heapify_down(vector<int>& nums, int n, int i) {
        int max_ = i, left = 2 * i + 1, right = left + 1;
        if (left < n && nums[left] > nums[max_]) max_ = left;
        if (right < n && nums[right] > nums[max_]) max_ = right;
        if (max_ != i) {
            std::swap(nums[i], nums[max_]);
            heapify_down(nums, n, max_);
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = n / 2 - 1; i >= 0; i--) heapify_down(nums, n, i);
        for (int i = 0; i < k-1; i++) {
            std::swap(nums[0], nums[n - 1 - i]);
            heapify_down(nums, n - 1 - i, 0);
        }
        return nums[0];
    }
};
```
### 方法2：`快速选择`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(\log n)$
```cpp
class Solution {
public:
    int qkselect(vector<int>& nums, int l, int r, int k) {
        if(l == r) return nums[k];
        int pivot = nums[l], i = l - 1, j = r + 1;
        while (i < j) {
            while (nums[++i] < pivot);
            while (nums[--j] > pivot);
            if(i < j) swap(nums[i], nums[j]);
        }
        if (k <= j) return qkselect(nums, l, j, k);
        else return qkselect(nums, j + 1, r, k);
    }
    int findKthLargest(vector<int>& nums, int k) {
        return qkselect(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
```