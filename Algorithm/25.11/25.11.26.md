# 25.11.26 算法刷题笔记

## 力扣：79. 单词搜索
**链接**：https://leetcode.cn/problems/word-search/  
**相关标签**：`深度优先搜索` `数组` `字符串` `回溯` `矩阵`  
**难度**：`中等`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(mn*3^L)$
- **空间复杂度**：$O(mn)$
```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        bool ans = false;
        auto dfs = [&](this auto&& dfs, int i, int x, int y) -> void {
            if(i == word.size()) ans = true;
            if(ans) return;
            if(x + 1 < board.size() && board[x+1][y] == word[i]){
                board[x+1][y] = ' ';
                dfs(i+1, x+1, y);
                board[x+1][y] = word[i];
            }
            if(ans) return;
            if(y + 1 < board[0].size() && board[x][y+1] == word[i]){
                board[x][y+1] = ' ';
                dfs(i+1, x, y+1);
                board[x][y+1] = word[i];
            }
            if(ans) return;
            if(x - 1 >= 0 && board[x-1][y] == word[i]){
                board[x-1][y] = ' ';
                dfs(i+1, x-1, y);
                board[x-1][y] = word[i];
            }
            if(ans) return;
            if(y - 1 >= 0 && board[x][y-1] == word[i]){
                board[x][y-1] = ' ';
                dfs(i+1, x, y-1);
                board[x][y-1] = word[i];
            }
        };
        for(int x=0; x<board.size(); x++){
            for(int y=0; y<board[0].size(); y++){
                if(board[x][y] == word[0]){
                    board[x][y] = ' ';
                    dfs(1, x, y);
                    board[x][y] = word[0];
                }
            }
        }
        return ans;
    }
};
```

## 力扣：236. 二叉树的最近公共祖先
**链接**：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/  
**相关标签**：`树` `深度优先搜索` `二叉树`  
**难度**：`中等`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left && right) return root;
        return left ? left : right;
    }
};
```