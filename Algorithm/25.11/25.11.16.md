# 25.11.16 算法刷题笔记

## 力扣：108. 将有序数组转换为二叉搜索树
**链接**：https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/  
**相关标签**：`树` `二叉搜索树` `数组` `分治` `二叉树`  
**难度**：`简单`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(\log n)$
```cpp
class Solution {
public:
    TreeNode* get(vector<int>& nums, int start, int end){
        int mid = (start + end) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = start > mid-1 ? nullptr : get(nums, start, mid-1);
        root->right = mid+1 > end ? nullptr : get(nums, mid+1, end);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return get(nums, 0, nums.size()-1);
    }
};
```

## 力扣：24. 两两交换链表中的节点
**链接**：https://leetcode.cn/problems/swap-nodes-in-pairs/  
**相关标签**：`递归` `链表`  
**难度**：`中等`
### 方法1：`迭代`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode a(0, head);
        ListNode* ans = &a;
        ListNode* fast = head;
        head = ans;
        while(fast && fast->next != nullptr){
            head->next = fast->next;
            fast->next = head->next->next;
            head->next->next = fast;
            head = fast;
            fast = fast->next;
        }
        return a.next;
    }
};
```