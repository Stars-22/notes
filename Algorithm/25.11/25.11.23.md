# 25.11.23 算法刷题笔记

## 力扣：146. LRU 缓存
**链接**：https://leetcode.cn/problems/lru-cache/  
**相关标签**：`设计` `哈希表` `链表` `双向链表`  
**难度**：`中等`
### 方法1：`哈希表 + 双向链表`
- **时间复杂度**：$O(1)$
- **空间复杂度**：$O(capacity)$
```cpp
class LRUCache {
    struct Node{
        int key;
        int val;
        Node* last;
        Node* next;
        Node(){};
        Node(int key, int val, Node* last, Node* next):key(key), val(val), last(last), next(next){};
    } head, tail;
    unordered_map<int, Node*> hmap;
    int capacity;
public:
    LRUCache(int capacity) : capacity(capacity) {
        head.next = &tail;
        tail.last = &head;
    }
    
    int get(int key) {
        if(hmap.find(key) == hmap.end()) return -1;
        Node* cur = hmap[key];
        cur->last->next = cur->next;
        cur->next->last = cur->last;
        tail.last->next = cur;
        cur->last = tail.last;
        cur->next = &tail;
        tail.last = cur;
        return cur->val;
    }
    
    void put(int key, int value) {
        if(hmap.find(key) != hmap.end()){
            hmap[key]->val = value;
            get(key);
            return;
        }
        if(hmap.size() == capacity){
            hmap.erase(head.next->key);
            head.next = head.next->next;
            delete head.next->last;
            head.next->last = &head;
        }
        Node* cur = new Node(key, value, tail.last, &tail);
        hmap[key] = cur;
        tail.last->next = cur;
        tail.last = cur;
    }
};
```

## 力扣：199. 二叉树的右视图
**链接**：https://leetcode.cn/problems/binary-tree-right-side-view/  
**相关标签**：`树` `深度优先搜索` `广度优先搜索` `二叉树`  
**难度**：`中等`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<int> ans;
    void getRight(TreeNode* root, int h){
        if(!root) return;
        if(ans.size() == h) ans.push_back(root->val);
        getRight(root->right, h+1);
        getRight(root->left, h+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        getRight(root, 0);
        return ans;
    }
};
```