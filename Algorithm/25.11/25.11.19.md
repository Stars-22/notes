# 25.11.19 算法刷题笔记

## 力扣：138. 随机链表的复制
**链接**：https://leetcode.cn/problems/copy-list-with-random-pointer/  
**相关标签**：`哈希表` `链表`  
**难度**：`中等`
### 方法1：`哈希表`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, int> hmap;
        vector<Node*> vmap;
        int n = 0;
        Node* cur = head;
        Node ans(0);
        Node* acur = &ans;
        while(cur){
            acur->next = new Node(cur->val);
            acur = acur->next;
            vmap.push_back(acur);
            hmap[cur] = n++;
            cur = cur->next;
        }
        cur = head;
        acur = ans.next;
        while(cur){
            acur->random = hmap.find(cur->random) != hmap.end() ? vmap[hmap[cur->random]] : nullptr;
            acur = acur->next;
            cur = cur->next;
        }
        return ans.next;
    }
};
```
### 方法2：`节点拆分`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        Node ans(0);
        Node* acur = &ans;
        for(Node* cur = head; cur; cur = cur->next->next){
            Node* temp = cur->next;
            cur->next = new Node(cur->val);
            cur->next->next = temp;
        }
        for(Node* cur = head; cur; cur = cur->next->next)
            if(cur->random) cur->next->random = cur->random->next;
        for(Node* cur = head; cur; cur = cur->next, acur = acur->next){
            acur->next = cur->next;
            cur->next = cur->next->next;
        }
        acur->next = nullptr;
        return ans.next;
    }
};
```

## 力扣：98. 验证二叉搜索树
**链接**：https://leetcode.cn/problems/validate-binary-search-tree/  
**相关标签**：`树` `深度优先搜索` `二叉搜索树` `二叉树`  
**难度**：`中等`
### 方法1：`递归`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    bool validate(TreeNode* root, long l, long r){
        if(!root) return true;
        if(root->val <= l || root->val >=r) return false;
        return validate(root->left, l, root->val) && 
               validate(root->right, root->val, r);
    }
    bool isValidBST(TreeNode* root) {
        return validate(root, LONG_MIN, LONG_MAX);
    }
};
```