# 25.11.02 算法刷题笔记

## 力扣：49. 字母异位词分组
**链接**：https://leetcode.cn/problems/group-anagrams/  
**相关标签**：`数组` `哈希表` `字符串` `排序`  
**难度**：`中等`
### 方法1：`频率计数`
- **时间复杂度**：$O(nk)$
- **空间复杂度**：$O(nk)$
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> hmap;
        for(const auto& s : strs){
            string a(52, '0');
            for(int i=0; i<s.size(); i++){
                int num = (s[i] - 'a') * 2 + 1;
                if(++a[num] >= 127){
                    a[num-1]++;
                    a[num] -= 127;
                }
            }
            hmap[a].push_back(s);
        }
        vector<vector<string>> ans;
        for(auto& a : hmap) ans.push_back(move(a.second));
        return ans;
    }
};
```

## 力扣：21. 合并两个有序链表
**链接**：https://leetcode.cn/problems/merge-two-sorted-lists/  
**相关标签**：`递归` `链表`  
**难度**：`简单`
### 方法1：`迭代`
- **时间复杂度**：$O(n+m)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode ans = ListNode(-101);
        ListNode* cur = &ans;
        while(list1 && list2){
            if(list1->val >= list2->val){
                cur->next = list2;
                list2 = list2->next;
            }
            else{
                cur->next = list1;
                list1 = list1->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return ans.next;
    }
};
```