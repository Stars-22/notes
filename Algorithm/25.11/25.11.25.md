# 25.11.25 算法刷题笔记

## 力扣：39. 组合总和
**链接**：https://leetcode.cn/problems/combination-sum/  
**相关标签**：`数组` `回溯`  
**难度**：`中等`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(S)$
- **空间复杂度**：$O(target)$
```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> temp;
        int k = 0;
        auto dfs = [&](this auto&& dfs, int i) -> void {
            for(; i<candidates.size(); i++){
                temp.push_back(candidates[i]);
                k += candidates[i];
                if(k == target) ans.push_back(temp);
                if(k < target) dfs(i);
                temp.pop_back();
                k -= candidates[i];
            }
        };
        dfs(0);
        return ans;
    }
};
```

## 力扣：437. 路径总和 III
**链接**：https://leetcode.cn/problems/path-sum-iii/  
**相关标签**：`树` `深度优先搜索` `二叉树`  
**难度**：`中等`
### 方法1：`深度优先搜索`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        unordered_map<long long, int> hmap{{0, 1}};
        int ans = 0;
        auto dfs = [&](this auto&& dfs, TreeNode* root, long long last) -> void {
            if(!root) return;
            last += root->val;
            if(hmap.count(last - targetSum)) ans += hmap[last - targetSum];
            hmap[last]++;
            dfs(root->left, last);
            dfs(root->right, last);
            hmap[last]--;
        };
        dfs(root, 0);
        return ans;
    }
};
```