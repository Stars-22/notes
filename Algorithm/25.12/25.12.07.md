# 25.12.07 算法刷题笔记

## 力扣：5. 最长回文子串
**链接**：https://leetcode.cn/problems/longest-palindromic-substring/  
**相关标签**：`双指针` `字符串` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(n^2)$
- **空间复杂度**：$O(n^2)$
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size(), ans = 1, l = 0;
        vector<vector<bool>> dp(n, vector<bool>(n, true));
        for(int i=0; i<n; i++){
            for(int j=0; j<i; j++){
                dp[i][j] = s[i] == s[j] && dp[i-1][j+1];
                if(dp[i][j] && i-j+1 > ans){
                    ans = i-j+1;
                    l = j;
                }
            }
        }
        return s.substr(l, ans);
    }
};
```
### 方法2：`Manacher算法`
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        string t = "#", ans = "";
        for(const char c : s){
            t += c;
            t += '#';
        }
        int n = t.size(), right = 0, center = 0, max_len = 0, max_center = 0;
        vector<int> armL(n, 0);
        for(int i=0; i<n; i++){
            if(i < right) armL[i] = min(right-i, armL[center*2-i]);
            while(i-armL[i]>=0 && i+armL[i]<n && t[i-armL[i]] == t[i+armL[i]]) armL[i]++;
            armL[i]--;
            if(i+armL[i] > right){
                right = i + armL[i];
                center = i;
            }
            if(armL[i] > max_len){
                max_len = armL[i];
                max_center = i;
            }
        }
        for(int i=max_center-max_len+1; i<max_center+max_len; i+=2) ans += s[(i-1)/2];
        return ans;
    }
};
```