# 25.12.08 算法刷题笔记

## 力扣：1143. 最长公共子序列
**链接**：https://leetcode.cn/problems/longest-common-subsequence/  
**相关标签**：`字符串` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(nm)$
- **空间复杂度**：$O(\min (n,m))$
```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size(), m = text2.size();
        vector<int> dp(m+1, 0);
        for(int i=0; i<n; i++){
            int last = 0;
            for(int j=1; j<=m; j++){
                int temp = dp[j];
                if(text1[i] == text2[j-1]) dp[j] = last + 1;
                else dp[j] = max(dp[j-1], dp[j]);
                last = temp;
            }
        }
        return dp[m];
    }
};
```

## 力扣：72. 编辑距离
**链接**：https://leetcode.cn/problems/edit-distance/  
**相关标签**：`字符串` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(nm)$
- **空间复杂度**：$O(\min (n,m))$
```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        if(word1.size() < word2.size()) swap(word1, word2);
        int n = word1.size(), m = word2.size();
        vector<int> dp(m+1);
        for (int j = 0; j <= m; j++) dp[j] = j;
        for(int i=1; i<=n; i++){
            int last = dp[0];
            dp[0] = i;
            for(int j=1; j<=m; j++){
                int temp = dp[j];
                if(word1[i-1] == word2[j-1]) dp[j] = last;
                else dp[j] = min(min(dp[j-1], dp[j]), last) + 1;
                last = temp;
            }
        }
        return dp[m];
    }
};
```