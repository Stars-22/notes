# 25.12.09 算法刷题笔记

## 力扣：139. 单词拆分
**链接**：https://leetcode.cn/problems/word-break/  
**相关标签**：`字典树` `记忆化搜索` `数组` `哈希表` `字符串` `动态规划`  
**难度**：`中等`
### 方法1：`动态规划`
- **时间复杂度**：$O(n^2)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> hset;
        for(const auto& s : wordDict) hset.insert(s);
        vector<bool> dp(s.size()+1, false);
        dp[0] = true;
        for(int i=1; i<=s.size(); i++){
            for(int j=0; j<i; j++){
                if(dp[j] && hset.find(s.substr(j, i-j)) != hset.end()){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```
### 方法2：`剪枝的动态规划`
- **时间复杂度**：$O(nk)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> hset(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size()+1, false);
        dp[0] = true;
        unordered_set<int> lengths;
        for (const auto& s : wordDict) lengths.insert(s.size());
        for(int i=1; i<=s.size(); i++){
            for(const auto& l : lengths){
                if(i >= l && dp[i-l] && hset.find(s.substr(i-l, l)) != hset.end()){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 力扣：300. 最长递增子序列
**链接**：https://leetcode.cn/problems/longest-increasing-subsequence/  
**相关标签**：`数组` `二分查找` `动态规划`  
**难度**：`中等`
### 方法1：`贪心 + 二分查找`
- **时间复杂度**：$O(n \log n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d = {INT_MIN};
        for(int i=0; i<nums.size(); i++){
            if(nums[i] > d.back()) d.push_back(nums[i]);
            else *(lower_bound(d.begin(), d.end(), nums[i])) = nums[i];;
        }
        return d.size()-1;
    }
};
```