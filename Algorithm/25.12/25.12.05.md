# 25.12.05 算法刷题笔记

## 力扣：33. 搜索旋转排序数组
**链接**：https://leetcode.cn/problems/search-in-rotated-sorted-array/  
**相关标签**：`数组` `二分查找`  
**难度**：`中等`
### 方法1：`二分查找`
- **时间复杂度**：$O(\log n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size()-1;
        while(l <= r){
            int mid = (l + r) / 2;
            if(nums[mid] == target) return mid;
            if(nums[l] <= nums[mid]){
                if(target >= nums[l] && target < nums[mid]) r = mid - 1;
                else l = mid + 1;
            }
            else{
                if(target > nums[mid] && target <= nums[r]) l = mid + 1;
                else r = mid - 1;
            }
        }
        return -1;
    }
};
```

## 力扣：34. 在排序数组中查找元素的第一个和最后一个位置
**链接**：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/  
**相关标签**：`数组` `二分查找`  
**难度**：`中等`
### 方法1：`二分查找`
- **时间复杂度**：$O(\log n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        auto l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        auto r = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;
        if(l >= nums.size() || nums[l] != target) return {-1, -1};
        return {static_cast<int>(l), static_cast<int>(r)};
    }
};
```

## 力扣：153. 寻找旋转排序数组中的最小值
**链接**：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/  
**相关标签**：`数组` `二分查找`  
**难度**：`中等`
### 方法1：`二分查找`
- **时间复杂度**：$O(\log n)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0, r = nums.size()-1, ans = INT_MAX;
        while(l <= r){
            int mid = (l + r) / 2;
            if(nums[l] <= nums[mid]){
                ans = min(ans, nums[l]);
                l = mid + 1;
            }
            else{
                ans = min(ans, nums[mid]);
                r = mid - 1;
            }
        }
        return ans;
    }
};
```

## 力扣：347. 前 K 个高频元素
**链接**：https://leetcode.cn/problems/top-k-frequent-elements/  
**相关标签**：`数组` `哈希表` `分治` `桶排序` `计数` `快速选择` `排序` `堆（优先队列）`  
**难度**：`中等`
### 方法1：`哈希表 + 优先队列`
- **时间复杂度**：$O(n \log n)$
- **空间复杂度**：$O(n)$
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        struct Node{
            int v;
            int n;
            Node(int v, int n) : v(v), n(n) {}
            bool operator<(const Node& other) const { return n < other.n; }
        };
        unordered_map<int, int> hmap;
        priority_queue<Node> q;
        vector<int> ans;
        for(const auto& n : nums) hmap[n]++;
        for(const auto& p : hmap) q.push(Node(p.first, p.second));
        for(; k>0; k--){
            ans.push_back(q.top().v);
            q.pop();
        }
        return ans;
    }
};
```