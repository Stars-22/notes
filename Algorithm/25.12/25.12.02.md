# 25.12.02 算法刷题笔记

## 力扣：4. 寻找两个正序数组的中位数
**链接**：https://leetcode.cn/problems/median-of-two-sorted-arrays/  
**相关标签**：`数组` `二分查找` `分治`  
**难度**：`困难`
### 方法1：`二分查找（尾递归）`
- **时间复杂度**：$O(\log (m+n))$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
private:
    int getK(vector<int>& nums1, vector<int>& nums2, int k, int l1, int r1, int l2, int r2){
        if (l1 >= r1) return nums2[l2 + k - 1];
        if (l2 >= r2) return nums1[l1 + k - 1];
        if(k == 1) return min(nums1[l1], nums2[l2]);
        int mid1 = l1 + min(r1 -l1, k/2) - 1;
        int mid2 = l2 + min(r2 -l2, k/2) - 1;
        if(nums1[mid1] < nums2[mid2])
            return getK(nums1, nums2, k-mid1+l1-1, mid1+1, r1, l2, r2);
        return getK(nums1, nums2, k-mid2+l2-1, l1, r1, mid2+1, r2);
    }
    int getK(vector<int>& nums1, vector<int>& nums2, int k){ return getK(nums1, nums2, k, 0, nums1.size(), 0, nums2.size()); }
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int nm = nums1.size() + nums2.size();
        if(nm % 2 == 0) return (getK(nums1, nums2, nm/2) + getK(nums1, nums2, nm/2+1)) / 2.0;
        return getK(nums1, nums2, (nm+1)/2);
    }
};
```
### 方法2：`二分查找（迭代）`
- **时间复杂度**：$O(\log (m+n))$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
private:
    int getK(vector<int>& nums1, vector<int>& nums2, int k){
        int l1 = 0, l2 = 0, r1 = nums1.size(), r2 = nums2.size();
        while(true){
            if (l1 >= r1) return nums2[l2 + k - 1];
            if (l2 >= r2) return nums1[l1 + k - 1];
            if(k == 1) return min(nums1[l1], nums2[l2]);
            int mid1 = l1 + min(r1 -l1, k/2) - 1;
            int mid2 = l2 + min(r2 -l2, k/2) - 1;
            if(nums1[mid1] < nums2[mid2]){
                k -= mid1 - l1 + 1;
                l1 = mid1 + 1;
            }
            else{
                k -= mid2 - l2 + 1;
                l2 = mid2 + 1;
            }
        }
    }
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int nm = nums1.size() + nums2.size();
        if(nm % 2 == 0) return (getK(nums1, nums2, nm/2) + getK(nums1, nums2, nm/2+1)) / 2.0;
        return getK(nums1, nums2, (nm+1)/2);
    }
};
```
### 方法3：`二分查找（迭代、优化）`
- **时间复杂度**：$O(\log (m+n))$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int l1 = 0, l2 = 0, r1 = nums1.size(), r2 = nums2.size(), k = (r1 + r2 + 1) / 2;
        bool v = (r1 + r2) % 2;
        while(true){
            if (l1 >= r1){
                if(!v) return (nums2[l2 + k - 1] + nums2[l2 + k]) / 2.0;
                return nums2[l2 + k - 1];
            }
            if (l2 >= r2){
                if(!v) return (nums1[l1 + k - 1] + nums1[l1 + k]) / 2.0;
                return nums1[l1 + k - 1];
            }
            if(k == 1){
                if(!v){
                    int last = min(nums1[l1], nums2[l2]);
                    if(nums1[l1] < nums2[l2]) l1++;
                    else l2++;
                    if(l1 >= r1) return (nums2[l2] + last) / 2.0;
                    if(l2 >= r2) return (nums1[l1] + last) / 2.0;
                    return (min(nums1[l1], nums2[l2]) + last) / 2.0;
                }
                else return min(nums1[l1], nums2[l2]);
            }
            int mid1 = l1 + min(r1 -l1, k/2) - 1;
            int mid2 = l2 + min(r2 -l2, k/2) - 1;
            if(nums1[mid1] < nums2[mid2]){
                k -= mid1 - l1 + 1;
                l1 = mid1 + 1;
            }
            else{
                k -= mid2 - l2 + 1;
                l2 = mid2 + 1;
            }
        }
    }
};
```
### 方法4：`二分查找（划分数组）`
- **时间复杂度**：$O(\log \min (m+n))$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        if(n > m) return findMedianSortedArrays(nums2, nums1);
        int l = 0, r = n, h = (r + m + 1) / 2;
        while(true){
            int i = (l + r) / 2, j = h - i;
            int l1 = i==0 ? INT_MIN : nums1[i-1];
            int r1 = i==n ? INT_MAX : nums1[i];
            int l2 = j==0 ? INT_MIN : nums2[j-1];
            int r2 = j==m ? INT_MAX : nums2[j];
            if(l1 > r2) r = i - 1;
            else if(l2 > r1) l = i + 1;
            else{
                if((n + m) % 2 == 1) return max(l1, l2);
                return (max(l1, l2) + min(r1, r2)) / 2.0;
            }
        }
    }
};
```