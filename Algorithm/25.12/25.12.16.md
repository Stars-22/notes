# 25.12.16 算法刷题笔记

## 力扣：3562. 折扣价交易股票的最大利润
**链接**：https://leetcode.cn/problems/maximum-profit-from-trading-stocks-with-discounts/  
**相关标签**：`树` `深度优先搜索` `数组` `动态规划`  
**难度**：`困难`
### 方法1：`树形动态规划`
- **时间复杂度**：$O(n*budget^2)$
- **空间复杂度**：$O(n*budget)$
```cpp
class Solution {
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        vector<vector<int>> son(n);
        for(const auto& h : hierarchy) son[h[0]-1].push_back(h[1]-1);
        auto dfs = [&](this auto&& dfs, int i) -> tuple<vector<int>, vector<int>, int> {
            int cost = present[i], dcost = present[i] / 2, size = cost;
            vector<int> sonDp0(budget+1, 0), sonDp1(budget+1, 0), dp0(budget+1), dp1(budget+1);
            for(const auto s : son[i]){
                auto [_sonDp0, _sonDp1, sSize] = dfs(s);
                size += sSize;
                for(int j=budget; j>=0; j--){
                    for(int k=0; k<=min(size, j); k++){
                        sonDp0[j] = max(sonDp0[j], _sonDp0[k]+sonDp0[j-k]);
                        sonDp1[j] = max(sonDp1[j], _sonDp1[k]+sonDp1[j-k]);
                    }
                }
            }
            for(int j=0; j<=budget; j++){
                dp0[j] = dp1[j] = sonDp0[j];
                if(j >= dcost) dp1[j] = max(dp1[j], sonDp1[j-dcost]+future[i]-dcost);
                if(j >= cost) dp0[j] = max(dp0[j], sonDp1[j-cost]+future[i]-cost);
            }
            return {dp0, dp1, size};
        };
        return std::get<0>(dfs(0))[budget];
    }
};
```