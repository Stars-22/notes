# 25.12.04 算法刷题笔记

## 力扣：74. 搜索二维矩阵
**链接**：https://leetcode.cn/problems/search-a-2d-matrix/  
**相关标签**：`数组` `二分查找` `矩阵`  
**难度**：`中等`
### 方法1：`两次二分查找`
- **时间复杂度**：$O(\log mn)$
- **空间复杂度**：$O(1)$
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        auto it = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector<int> a){
            return b < a[0];
        });
        if(it == matrix.begin()) return false;
        --it;
        return binary_search(it->begin(), it->end(), target);
    }
};
```

## 力扣：131. 分割回文串
**链接**：https://leetcode.cn/problems/palindrome-partitioning/  
**相关标签**：`字符串` `动态规划` `回溯`  
**难度**：`中等`
### 方法1：`回溯 + 动态规划预处理`
- **时间复杂度**：$O(n*2^n)$
- **空间复杂度**：$O(n^2)$
```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, true));
        vector<vector<string>> ans;
        vector<string> temp;
        for(int i=n-1; i>=0; i--)
            for(int j=i+1; j<n; j++)
                dp[i][j] = s[i] == s[j] && dp[i+1][j-1];
        auto dfs = [&](this auto&& dfs, int k){
            if(k == n){
                ans.push_back(temp);
                return;
            }
            for(int i=k; i<n; i++){
                if(dp[k][i]){
                    temp.push_back(s.substr(k, i-k+1));
                    dfs(i+1);
                    temp.pop_back();
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```